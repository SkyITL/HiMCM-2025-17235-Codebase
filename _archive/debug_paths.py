#!/usr/bin/env python3
"""Debug paths generated by optimizer."""

import json
from simulator import Simulation
from optimal_rescue_model import OptimalRescueModel

# Load config
with open('/Users/skyliu/Downloads/mall1withoccupants.json', 'r') as f:
    config = json.load(f)

# Setup rescue-only scenario
rooms = [v for v in config['vertices'] if v['type'] == 'room']
config['occupancy_probabilities'] = {}
for room in rooms:
    config['occupancy_probabilities'][room['id']] = {
        'capable': {'min': 0, 'max': 0},
        'incapable': {'min': 3, 'max': 3}
    }

# Create sim
sim = Simulation(config=config, num_firefighters=2, fire_origin='room_14', seed=42)

# Mark all rooms as visited
all_rooms = [v_id for v_id, v in sim.vertices.items() if v.type == 'room']
for ff in sim.firefighters.values():
    ff.visited_vertices.update(all_rooms)

# Create model
model = OptimalRescueModel(use_lp=False)

# Run tick 0 to trigger phase transition
state = sim.read()
actions = model.get_actions(state)

# Inspect first item for each firefighter
print("\n" + "="*70)
print("INSPECTING FIRST ITEM FOR EACH FIREFIGHTER")
print("="*70)

for ff_id in ['ff_0', 'ff_1']:
    ff_state = state['firefighters'][ff_id]
    plans = model.coordinator.ff_plans[ff_id]

    print(f"\n{ff_id}:")
    print(f"  Starting position: {ff_state['position']}")
    print(f"  Total items: {len(plans)}")

    if plans:
        first_plan = plans[0]
        item = first_plan.item

        print(f"\n  First item:")
        print(f"    Vector: {item['vector']}")
        print(f"    Visit sequence: {item['visit_sequence']}")
        print(f"    Entry exit: {item['entry_exit']}")
        print(f"    Drop exit: {item['drop_exit']}")
        print(f"    Full path: {item['full_path']}")
        print(f"    Time: {item['time']:.1f}")
        print(f"    Value: {item['value']:.3f}")

        # Check path validity
        print(f"\n  Path validation:")
        path = item['full_path']
        print(f"    Path has {len(path)} vertices")

        # Build adjacency from edges
        adjacency = {}
        for edge_id, edge_data in state['graph']['edges'].items():
            va = edge_data['vertex_a']
            vb = edge_data['vertex_b']

            if va not in adjacency:
                adjacency[va] = []
            if vb not in adjacency:
                adjacency[vb] = []

            adjacency[va].append(vb)
            adjacency[vb].append(va)

        for i in range(len(path) - 1):
            v1 = path[i]
            v2 = path[i+1]

            # Check if adjacent
            if v2 in adjacency.get(v1, []):
                print(f"    {v1} -> {v2}: OK")
            else:
                print(f"    {v1} -> {v2}: ERROR - NOT ADJACENT!")
                print(f"      {v1} adjacency: {adjacency.get(v1, [])}")
